#!/usr/bin/env python

import math
import Read_CIF
import psi4
import re
import os
from psi4.driver.wrapper_autofrag import auto_fragments

# ==================================================================
def readmatchf(pattern, file):
    """If the name of a file matches a pattern read the lines contained in it, and return the contents as a list of lines."""

    contents = []

    if re.match(pattern, file):  # Match filenames with pattern

        with open(file, 'r') as f:
            contents = f.readlines()

    return contents
# ==================================================================

# ==================================================================
def scellcntr():
    """Compute the center of coordinates of a series of .xyz files with a matching pattern in the filename.
    Returns a list with fragment names, x, y, and z coordinates in lists of floats and the coordinates of the center."""

    frg = [] # Fragments file names.
    x = [] # Values of x coordinates.
    y = [] # Values of y coordinates.
    z = [] # Values of z coordinates.

    directory = os.getcwd()
    files = os.listdir(directory)

    for file in files:
        lines = readmatchf('^f[0-9]+.xyz$', file)

        i = 0
        for i in range(len(lines)):

            if i < 2:
                continue

            else:
                info = lines[i].split()
                frg.append(file)
                x.append(float(info[1]))
                y.append(float(info[2]))
                z.append(float(info[3]))

    cntr_x = (max(x) - min(x))/2.0
    cntr_y = (max(y) - min(y))/2.0
    cntr_z = (max(z) - min(z))/2.0

    print("Center of the supercell located at:")
    print("x= %10.5f" % (cntr_x))
    print("y= %10.5f" % (cntr_y))
    print("z= %10.5f" % (cntr_z))
    print("")

    return frg, x, y, z, cntr_x, cntr_y, cntr_z
# ==================================================================

# ==================================================================
def posvecmag():
    """Using the scellcntr() function it computes the magnitude of the position vector of the atoms read by the scellcntr() function.
    Returns the fragment filename and the magnitude of the position vector."""

    frg, x, y, z, cntr_x, cntr_y, cntr_z = scellcntr()

    r = []

    for j in range(len(x)):
        r.append(math.sqrt((x[j] - cntr_x)**2.0 + (y[j] - cntr_y)**2.0 + (z[j] - cntr_z)**2.0))

    print("Magnitudes of the position vectors calculated.")
    print("")

    return frg, r
# ==================================================================

# ==================================================================
def proximity():
    """Using position vector magnitude, computed in posvecmag(). This function returns a list of fragments filenames
    with fragments containing atoms closest to the center of the supercell first."""

    frg, r = posvecmag()

    frgprox = []

    for pair in sorted(enumerate(r), key=lambda item:item[1]):
        if frg[pair[0]] in frgprox:
            continue
        else:
            frgprox.append(frg[pair[0]])

    print("Molecules organized based on the closest atom to the")
    print("center of the supercell.")
    print("")

    return frgprox
# ==================================================================

# ==================================================================
def frgs2mols():
    """Takes fragments and a list of proximity to the center of the supercell, generated by the proximity() function.
    Writes new files with molecules indexed by increasing proximity to the center of the supercell."""

    directory = os.getcwd()
    proxlist = proximity()
    molecule = 0

    for file in proxlist:
        molecule += 1
        molfname = "m" + str(molecule).zfill(len(proxlist[-1]) - 5) + ".xyz"

        with open(file, 'r') as ffile, open(molfname, 'w') as mfile:

            for l in ffile.readlines():

                if l.startswith("Fragment"):
                    newl = "Molecule " + str(molecule) + " (" + l[:-1] + ")\n"
                    mfile.write(newl)

                else:
                    mfile.write(l)

        os.remove(os.path.join(directory, file))

        print("Fragment " + str(file) + " has been rewritten to: " + str(molfname))

    print("")

    return
# ==================================================================

# ==================================================================
# Discard incomplete molecules from the list of fragments.
# requires the expecte number of atoms as input.

# WARNING: What if there are more than two types of molecules in the
#          unit cell? n_atom_frg should be passed as a list with
#          possible numbers of atoms in a fragment.

def frags_filter(n_atm_frg):
    
    # Remove files that match a filename pattern 
    # and have an unexpected number of atoms.

    directory = os.getcwd()
    files = os.listdir(directory)
    incmolcounter = 0
    
    for file in files:

        if re.match('^f[0-9]+.xyz$', file): # Match filenames f???.xyz

            with open(file, 'r') as f: # WARNING: Obsolete. Use readmatchf function.
                lines = f.readlines()

                if len(lines) != n_atm_frg + 2: # Match files with unexpected atoms.
                    print("Expected " + str(n_atm_frg)\
                          + " atoms. Found only " + str(len(lines) - 2)\
                          + ". Removing: " + file)

                    os.remove(os.path.join(directory,file))

                    incmolcounter += 1
    
    print ("Removed %s fragments." % incmolcounter)
    
    return
# ==================================================================


# ==================================================================
# Main program.

def main():

    # ------------------------------------------------------------------
    # Read a CIF file and generates a supercell.
    print ("")
    print ("=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= ")
    print (" STEP 1. GENERATION OF A SUPERCELL FROM A CIF FILE.")
    print ("=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= ")
    print ("")
    
    ReadCifIn = 'Benzene-138K.cif'  # CIF input file. # WARNING: Hardcoded for now!
    ReadCifOut = 'Benzene-138K.xyz' # XYZ output file. # WARNING: Hardcoded for now!
    ReadCifA = '2'                  # X replicas. # WARNING: Hardcoded for now!
    ReadCifB = '2'                  # Y replicas. # WARNING: Hardcoded for now!
    ReadCifC = '2'                  # Z replicas. # WARNING: Hardcoded for now!
    
    args = ['', '-i', ReadCifIn, '-o', ReadCifOut, '-b', ReadCifA, ReadCifB, ReadCifC]
    
    print ("The following arguments will be passed to the CIF reader script:")
    print ("./Read_CIF.py" + " ".join(str(arg) for arg in args))
    print ("")
    
    print ("--------------------------------------------------------------------- ")
    Read_CIF.main(args)
    print ("--------------------------------------------------------------------- ")
    # ------------------------------------------------------------------
    
    # ------------------------------------------------------------------
    # Take the supercell .xyz file
    # And generate .xyz files with all possible monomers.
    print ("")
    print ("=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= ")
    print (" STEP 2. EXTRACTION OF MONOMERS FROM THE SUPERCELL.")
    print ("=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= ")
    print ("")
    
    # Read the lines in the .xyz file recently generated by Read_CIF.py
    with open(ReadCifOut) as fxyz:
        sxyz = fxyz.readlines()
    
    # Generate a SuperCell object.
    #SuperCell = psi4.geometry('\n'.join(sxyz[2:]))
    #SuperCell.update_geometry()
    #print (SuperCell.print_out())
    
    # Generate fragments from SuperCell.
    #CellFrags = auto_fragments(molecule = SuperCell)
    #print (CellFrags.natom())
    #print (CellFrags.nfragments())
    
    # Read the output of the automatic fragmentation.
    p4frag = "bzfrag.p4" # WARNING: Name of the fragmented super cell
                         #          file is temporarily hardcoded.

    with open(p4frag) as cellfrags:
        frags = cellfrags.readlines()

    # Generate .xyz files for each fragment.
    numfrags = 664       # WARNING: Number of fragments temporarily hardcoded!
    numfatoms = 12       # WARNING: Number of atoms per fragment hardcoded! What if there are two types of molecules?
    frg_separator = "--" # Fragment separator string.
    fcounter = 1         # Counter of processed fragments.
    lcounter = 0         # Counter of lines.
    HeaderLine = True    # Flag for first line of a fragment .xyz file.
    
    for line in frags:
        lcounter += 1
        
        if line.startswith(frg_separator):
            fcounter += 1
            HeaderLine = True
        
        else:
            ffnidx = "f" + str(fcounter).zfill(len(str(numfrags))) \
                     + ".xyz"
            with open(ffnidx, "a") as frgxyz: # WARNING: File exists?
                
                if HeaderLine == True:
                    frgxyz.write(str(numfatoms) + "\n"+ "Fragment " 
                    + str(fcounter) + "\n")
                    HeaderLine = False
                
                if HeaderLine == False:
                    frgxyz.write(line)
    
    # Discard fragments that are not a complete molecule.
    
    print("")
    print("Detecting fragments with incomplete molecules:")
    print("")

    frags_filter(numfatoms)

    # Organize fragments according to their distance to the center of
    # the supercell, produce molecule files.
    
    print("")
    print("Organizing molecules according to their separation to the")
    print("center of the supercell:")
    print("")

    frgs2mols()

    # ------------------------------------------------------------------
    
    # ------------------------------------------------------------------
    # Loop through all monomers and generate dimers with all other
    # monomers.
    #
    # Filter dimers that are too distant apart.
    #
    # Filter out and keep count of all non-unique dimers, using the
    # nuclear repulsion energy criteria.
    # ------------------------------------------------------------------
    
    # ------------------------------------------------------------------
    # Loop through all dimers and generate trimers with all other
    # monomers.
    #
    # Filter trimers that are too distant apart.
    #
    # Filter out and keep count of all non-unique trimers, using 
    # ArbAlign.
    # ------------------------------------------------------------------
    
    # .
    # .
    # .
    
    # ------------------------------------------------------------------
    # Run plesantly parallel PSI4 computations on all the final list of 
    # monomers, dimers, trimers, etc.
    #
    # Multiply the resulting energy of each one by the degeneracy factor.
    #
    # Sum results to get a lattice energy.
    # ------------------------------------------------------------------
# ==================================================================

if __name__ == "__main__":
    main()
